ideas for zak (Z80 Abstractions for Kernels) language

PLEASE NOTE!  This was/is a scratch file for working out ideas.  The actual definition of the zak language belongs in the file 'LANGUAGE'.
For things which that file does not specify, _this_ file contains descriptions of plans, limits of the current implementation, and limits of older versions of the implementation.  Don't trust it...

data types: void, bool, byte, word, pointer, struct, union?, enum?, array
use IY for variable stack (totally separate to the SP push/pop/call/ret stack)
will need a macroexpansion facility
would be nice to have inline functions for things like 32-bit arithmetic (and even 16-bit multiplies etc)

when in doubt, try to be C-like

compiler will have to do register allocation, which means taking into account the Z80's operand restrictions
initially, make no attempt to do optimisation in the compiler beyond 'sane code generation' and reg. alloc.

calling conventions:
* anything but SP (and R, I suppose) is callee-clobbered
* return value location:
	may be specified as part of function signature ("word get_dest __DE (void);"), else following defaults:
	- bool, byte, enum: A
	- word, pointer: HL
	- struct, union: caller-stack, compiler passes pointer as extra argument.  Initial version might not do this for you (i.e. entirely reject functions returning struct)
	- array: forbidden
* argument locations:
	may be specified as part of function signature ("byte do_something(word __BC src, word __DE dst);").  It's there to make life easier for asm callees, which don't even have to know they're being called from zak; but zak functions can do it too (though probably shouldn't).
	otherwise, everything is passed on the stack
	stack size per function is restricted to 128 bytes, so big structs or arrays on stack hurt!  (Struct sizes - even structs that only ever appear as pointers - are also restricted to 128 bytes, and for the same reason: the maximum positive displacement of an indexed load is +127.)
	if you try to pass an array to a function, it's passed by reference (i.e. it degrades to a pointer).  A function *must not* have a formal parameter of array type, nor of struct type (stick to pointers).  Though, we might add support for struct parameters later.

Caller constructs the initial stack frame.  It starts with 'byte frame_len;', which is used only for debugging purposes, but _always_ present
frame_len does not include itself in the length.  IY points to the byte _after_ frame_len.
Then follow the arguments, in listed order (a struct- or union-return pointer goes first)
Caller makes the call with PUSH IY; IY := <callee-frame-pointer>; CALL callee
Callee then extends this stack frame to make room for its local variables; it modifies frame_len (if we're paranoid, it first checks the old value)
On return, callee simply RETs, and caller does POP IY to get its own stack pointer back
Caller might then decide to extend its stack frame further, overwriting the stale callee stack frame.  This might be done to minimise total stack usage (eg. we put something big on the stack after the last call), but relies on the compiler KNOWING the flow of control and that there's no way we can end up having overlapping liveness, which is probably more optimisation than a first version needs.

Beware! (differences from C):
* The assign-ish operators return _the value written_, not the contents of the variable written to.  Because that's waaay easier to implement.
* The precedence and associativity of binary operators are different.  See LANGUAGE for details.
* A function with no parameters is declared as "func()", not "func(void)".
* A string literal is a 'const char []'.
