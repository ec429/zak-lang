Implementation Notes for the zak compiler
=========================================

The compiler is built in stages, as denoted by the following diagram:

    source->PAR->AST->TAC->RTL->GEN->assembly

These stages are:
PAR: the parser.  Builds a parse tree from the token stream.  Implemented using
 pyparsing (https://pythonhosted.org/pyparsing/), a combinatorial parser.  It's
 recursive descent and we don't use lookahead, so we have to take care to avoid
 left-recursion.
 There is a close correspondence between expressions in the parser code and
 productions in the specification of the grammar (see file LANGUAGE).
 [class Parser in parser.py]
AST: the Abstract Syntax Tree builder.  Converts the parser output into object
 trees more closely matching the semantics of the language.  The main nontrivial
 transformation is the conversion of type names (e.g. in declarations), as they
 are written 'inside-out' in the syntax.  The type objects (subclasses of Type)
 are used by some of the following stages.
 As a rule, an AST node class should have a 'build' classmethod which interprets
 the PAR output; separating this from the __init__ allows later stages of the
 pipeline to create their own AST objects, e.g. to rewrite the AST to support
 optimisation or to convert an expression into another form already handled.
 [class AST_builder in ast_build.py]
TAC: Two-Address Code, the first intermediate form.  Converts expressions,
 statements etc. into sequences of TACStatements, which (with the arguable
 exception of TACCall) have at most two arguments.  In order to do this, the
 TACifier creates gensyms to hold intermediate results; these are normally
 assumed to be unneeded ('killable') as soon as they have been used as the src
 (source) name of a TACStatement (some statements either don't imply a kill at
 all, or imply a kill of both their src and dst - for instance TACWrite).  When
 a gensym is not killable (e.g. it is the address for a read-modify-write of an
 lvalue) it is wrapped in a NoKill object (in this example, the read would use
 a NoKill while the write would use the bare Gensym, as the write is the last
 use of the symbol and can thus kill it).
 [class TACifier in tacifier.py]
RTL: Register Transfer Language, the second intermediate form.  Allocates
 storage for static and auto variables.  Performs register allocation on the
 stream of TACStatements for each function, generating a stream of
 RTLStatements including the operations necessary to fill and spill symbols to
 and from registers as needed.  At synchronisation points such as returns (or,
 when they're implemented, conditionals or jumps), will spill everything (but
 elide spill writes of symbols that haven't been dirtied).  Moreover, at labels
 and (again, to an extent) conditionals, registers may be considered stale and
 the symbols they held will need refilling.
 Optimisations here include detecting local spills that are _never_ refilled,
 and (if the local variable never has its address taken) eliding the spill.
 And, again, detecting local variables (whose address is not taken) which are
 never filled or spilled, and eliding their stack slot.
 A 'kill' of a symbol (which must be a gensym) implies that it will not be
 needed again, so any registers which were holding a copy of it are freed.  This
 often allows us to avoid ever spilling the symbol (as it is not possible to
 take the address of a gensym) and thus elide the stack slot.
 [class Allocator in allocator.py]
GEN: the code generator.  Converts RTLStatements into actual Z80 assembly
 language text, adding them to the bss, data or text section as appropriate.
 [class FunctionGenerator in codegen.py]
 Also, the global variable generator; converts static global variables into
 assembler directives, adding them to the bss or data section as appropriate.
 [class GlobalGenerator in codegen.py]
